// Generated by CoffeeScript 2.7.0
(function() {
  // to add a course:
  // - add entry to course_data.json object
  // - instantiate Course instance from entry in course_data object
  // - add course to courses array
  // - add course to any course plan's requirements and associated groups

  // to deprecate a course:
  // - set deprecated: true in the course_data.json entry
  // - optionally set last_offered_year and last_offered_term

  // to schedule availability:
  // - set first_offered_year and first_offered_term for future courses
  // - set last_offered_year and last_offered_term for courses being phased out

  // Load course data from JSON file
  var CHEM_105, CHEM_106, CHEM_109, CHEM_115, Course, DegreePlan, MATH_112, MATH_114, MATH_215, MATH_216, MATH_312, MATH_345, MSE_120, MSE_221, MSE_315, MSE_350, MSE_357, MSE_372, MSE_374, MSE_451, PHYS_115, PHYS_186, PHYS_226, PHYS_229, PHYS_231, PHYS_232, PHYS_240, PHYS_255, PHYS_308, PHYS_315, PHYS_332, PHYS_332_legacy, PHYS_333, PHYS_340, PHYS_350, PHYS_356, PHYS_360, PHYS_365, PHYS_367, PHYS_375, PHYS_415, PHYS_430, PHYS_445, PHYS_465, PHYS_486, YearTerm, course, courseDataJson, course_data, courses, current_month, current_year, degree_plan_data, degree_plans, deprecated_synonyms, first_term, get_course, get_course_from_element_id, get_degree_plan, j, len, loadCourseData, second_term, today, wizard, year_terms;

  courseDataJson = null;

  loadCourseData = function() {
    return $.ajax({
      url: '/js/course_data.json',
      dataType: 'json',
      async: false,
      success: function(data) {
        return courseDataJson = data;
      },
      error: function(xhr, status, error) {
        return console.error(`Error loading course data: ${error}`);
      }
    });
  };

  loadCourseData();

  deprecated_synonyms = (courseDataJson != null ? courseDataJson.deprecated_synonyms : void 0) || ['discontinued', 'deprecated', 'legacy', 'old'];

  course_data = courseDataJson != null ? courseDataJson.course_data : void 0;

  Course = class Course {
    constructor(course_info) {
      this.course_info = course_info;
      // unpack course data object
      this.field = this.course_info.field;
      this.number = this.course_info.number;
      this.name = this.course_info.name;
      this.lecture_hours = this.course_info.lecture_hours;
      this.lab_hours = this.course_info.lab_hours;
      this.credits = this.course_info.credits;
      this.description = this.course_info.description;
      this.le = this.course_info.le;
      this.deprecated = this.course_info.deprecated || false;
      this.last_offered_year = this.course_info.last_offered_year;
      this.last_offered_term = this.course_info.last_offered_term;
      this.first_offered_year = this.course_info.first_offered_year;
      this.first_offered_term = this.course_info.first_offered_term;
      // designations are strings, reguaar values hold actual courses
      // actual courses need to be set up later, since there's no guarantee 
      // the courses already exist, nor is there a way to get at them

      // prereqs: course must be taken BEFORE enrolling
      // coreqs: course must be taken BEFORE or WHILE enrolling
      // prereq_options: some number of these courses must be taken BEFORE enrolling
      // options: at least one of these courses must be taken BEFORE enrolling
      // exclude: cannot enroll if any of these courses have been completed
      this.prereq_designations = [];
      this.coreq_designations = [];
      this.combo_option_designations = [];
      this.option_designations = [];
      this.exclude_designations = [];
      this.prereqs = [];
      this.coreqs = [];
      this.combo_options = [];
      this.combo_option_min = 0;
      this.options = [];
      this.exclusions = [];
      if (this.course_info.requirements !== null) {
        if (this.course_info.requirements.prereqs !== void 0) {
          this.prereq_designations = this.course_info.requirements.prereqs;
        }
        if (this.course_info.requirements.coreqs !== void 0) {
          this.coreq_designations = this.course_info.requirements.coreqs;
        }
        if (this.course_info.requirements.combo !== void 0) {
          this.combo_option_designations = this.course_info.requirements.combo.options;
          this.combo_option_min = this.course_info.requirements.combo.min;
        }
        if (this.course_info.requirements.options !== void 0) {
          this.option_designations = this.course_info.requirements.options;
        }
        if (this.course_info.requirements.exclude !== void 0) {
          this.exclude_designations = this.course_info.requirements.exclude;
        }
      }
      this.years_offered = this.course_info.years_offered;
      this.terms_offered = this.course_info.terms_offered;
      // HTML helpers
      this.context_classes = ['default', 'primary', 'secondary', 'success', 'warning', 'danger', 'thick'];
      this.all_border_classes = (this.context_classes.map(function(cls) {
        return 'border-' + cls;
      })).join(' ');
      this.all_bg_classes = (this.context_classes.map(function(cls) {
        return 'bg-' + cls;
      })).join(' ');
      this.all_btn_classes = (this.context_classes.map(function(cls) {
        return 'btn-' + cls;
      })).join(' ');
      // Generate id suffix for distinguishing between similar courses
      // This makes deprecated/legacy versions have unique identifiers
      this.id_suffix = this.compute_id_suffix();
      
      // Generate all the IDs and selectors
      this.setup_ids_and_selectors();
      // state variables
      this.completed = false;
      this.enrolling = false;
      this.year_term_taken = false;
      // Generate the HTML card
      this.generate_html_card();
    }

    
      // Compute a suffix to add to IDs for distinguishing different versions of courses
    compute_id_suffix() {
      var id_suffix;
      id_suffix = "";
      
      // Add a suffix for deprecated courses to distinguish them
      if (this.deprecated) {
        // For regular deprecated courses, just use "_legacy"
        id_suffix = "_legacy";
      }
      
      // You could add more suffix rules here for other special cases
      return id_suffix;
    }

    // Set up all the IDs and selectors used for HTML elements
    setup_ids_and_selectors() {
      this.completed_id = `${this.field}-${this.number}${this.id_suffix}-completed`;
      this.enrolling_id = `${this.field}-${this.number}${this.id_suffix}-enrolling`;
      this.card_id = `${this.field}${this.number}${this.id_suffix}`;
      this.modal_id = `${this.field}-${this.number}${this.id_suffix}`;
      this.completed_sel = '#' + this.completed_id;
      this.enrolling_sel = '#' + this.enrolling_id;
      this.card_sel = '#' + this.card_id;
      this.header_sel = this.card_sel + '>h5.card-header';
      return this.modal_sel = '#' + this.modal_id;
    }

    
      // Generate the HTML for the course card
    generate_html_card() {
      this.html_card = `<div class='card' id='${this.card_id}'>\n`;
      this.html_card += `  <h5 class='card-header'>${this.field} ${this.number} <span class='font-italic'>(${this.credits} credits)</span></h5>\n`;
      this.html_card += "  <div class='card-body'>\n";
      this.html_card += `    <h5 class='card-title'>${this.name}</h5>\n`;
      // @html_card += "    <p class='card-text'>#{@description}</p>\n"
      this.html_card += "    <div class='row'>\n";
      this.html_card += "      <div class='col-5'>\n";
      this.html_card += `        <button type='button' class='btn btn-sm description' id='${this.modal_id}'>Details</button>\n`;
      this.html_card += "     </div>\n";
      this.html_card += "      <div class='col-7 px-1'>\n";
      this.html_card += "        <div class='custom-control custom-switch'>\n";
      this.html_card += `          <input type='checkbox' class='custom-control-input completed' id='${this.completed_id}'>\n`;
      this.html_card += `          <label for='${this.completed_id}' class='custom-control-label'>Completed</label>\n`;
      this.html_card += "        </div>\n";
      this.html_card += "        <div class='custom-control custom-switch'>\n";
      this.html_card += `          <input type='checkbox' class='custom-control-input enrolling' id='${this.enrolling_id}'>\n`;
      this.html_card += `          <label for='${this.enrolling_id}' class='custom-control-label'>Enrolling</label>\n`;
      this.html_card += "        </div>\n";
      this.html_card += "      </div>\n";
      this.html_card += "    </div>\n";
      this.html_card += "  </div>\n";
      return this.html_card += "</div>";
    }

    toString() {
      return `${this.field} ${this.number}`;
    }

    toggle_completed() {
      return this.completed = !this.completed;
    }

    toggle_enrolling() {
      return this.enrolling = !this.enrolling;
    }

    update_modal(year_term) {
      var availability, isAvailable;
      // Update modal content
      $('#course-info-label').html(`${this.field} ${this.number}: ${this.name}`);
      $('#course-description').html('');
      $('#course-description').append(`<p>${this.description}</p>`);
      $('#course-description').append(`<p>Lecture Hours: ${this.lecture_hours}; Lab Hours: ${this.lab_hours}</p>`);
      if (this.prereq_designations.length > 0) {
        $('#course-description').append(`<p><span class='font-italic'>Prerequisites:</span> ${this.prereq_designations.join(', ')}</p>`);
      }
      if (this.coreq_designations.length > 0) {
        $('#course-description').append(`<p><span class='font-italic'>Corequisites:</span> ${this.coreq_designations.join(', ')}</p>`);
      }
      if (this.exclude_designations.length > 0) {
        $('#course-description').append(`<p><span class='font-italic'>No credit if taken with/after:</span> ${this.exclude_designations.join(', ')}</p>`);
      }
      if (this.combo_option_designations.length > 0) {
        $('#course-description').append(`<p><span class='font-italic'>Must have taken at least ${this.combo_option_min} of:</span> ${this.combo_option_designations.join(', ')}</p>`);
      }
      // Update availability information
      availability = 'Offered ';
      
      // Check for special cases first (deprecated or future courses)
      if (this.deprecated) {
        if (this.last_offered_year && this.last_offered_term) {
          availability = `<span class='text-danger'>Discontinued. Last offered in the ${this.last_offered_term} term of ${this.last_offered_year}.</span>`;
        } else {
          availability = "<span class='text-danger'>Discontinued. No longer offered.</span>";
        }
      } else if ((this.first_offered_year != null) && (this.first_offered_term != null)) {
        // Format varies based on whether it's a new version or just a future course
        if (this.name.toLowerCase().includes('new version')) {
          availability = `<span class='text-success'>New version. First offered in the ${this.first_offered_term} term of ${this.first_offered_year}.</span>`;
        } else {
          availability = `<span class='text-info'>Coming soon. First offered in the ${this.first_offered_term} term of ${this.first_offered_year}.`;
          
          // Add additional information about regular offering pattern
          if (this.years_offered === 'all') {
            availability += ` Will be offered in the ${this.terms_offered} term every year thereafter.</span>`;
          } else {
            availability += ` Will be offered in the ${this.terms_offered} term of ${this.years_offered} years thereafter.</span>`;
          }
        }
      // Regular offerings (not deprecated or future)
      } else if (this.terms_offered === 'all') {
        availability += 'every term.';
      } else if (this.years_offered === 'all') {
        availability += `in the <span class='font-weight-bold'>${this.terms_offered} term</span> every year.`;
      } else {
        availability += `in the <span class='font-weight-bold'>${this.terms_offered} term of ${this.years_offered} years</span>.`;
      }
      $('#course-description').append(`<p>${availability}</p>`);
      
      // Update button states
      isAvailable = this.available(year_term);
      return $('#modal-enrolling').prop('disabled', !isAvailable || this.completed);
    }

    // update coreqs and prereqs from list of courses. Uses designations to 
    // query an array of courses, and then makes the actual course objects the
    // prerequisistes, corequisites, etc.
    update_requirements(courses) {
      var basic_match, course, designation, j, k, l, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, m, matched, n, name_match, o, p, q, r, ref, ref1, ref2, ref3, ref4, results, s, u;
      if (this.prereq_designations.length !== 0) {
        ref = this.prereq_designations;
        for (j = 0, len = ref.length; j < len; j++) {
          designation = ref[j];
          for (k = 0, len1 = courses.length; k < len1; k++) {
            course = courses[k];
            if (`${course.field} ${course.number}` === designation) {
              this.prereqs.push(course);
            }
          }
        }
      }
      ref1 = this.coreq_designations;
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        designation = ref1[l];
        for (m = 0, len3 = courses.length; m < len3; m++) {
          course = courses[m];
          if (`${course.field} ${course.number}` === designation) {
            this.coreqs.push(course);
          }
        }
      }
      ref2 = this.combo_option_designations;
      for (n = 0, len4 = ref2.length; n < len4; n++) {
        designation = ref2[n];
        for (o = 0, len5 = courses.length; o < len5; o++) {
          course = courses[o];
          if (`${course.field} ${course.number}` === designation) {
            this.combo_options.push(course);
          }
        }
      }
      ref3 = this.option_designations;
      for (p = 0, len6 = ref3.length; p < len6; p++) {
        designation = ref3[p];
        for (q = 0, len7 = courses.length; q < len7; q++) {
          course = courses[q];
          if (`${course.field} ${course.number}` === designation) {
            this.options.push(course);
          }
        }
      }
      ref4 = this.exclude_designations;
      
      // For exclusions, we need special handling to ensure all versions are properly excluded
      results = [];
      for (r = 0, len8 = ref4.length; r < len8; r++) {
        designation = ref4[r];
        matched = false;
        
        // Check if this is a PHYS 332 exclusion
        if (designation === "PHYS 332" || designation === "PHYS 332 legacy" || designation.includes("University Physics III")) {
          if (this.field === "PHYS" && this.number === 332) {
            // When PHYS 332 is excluding PHYS 332 legacy or vice versa, 
            // we need to handle the special case
            if (this.deprecated) {

              // This is PHYS 332 legacy, so exclude the non-legacy version
              for (s = 0, len9 = courses.length; s < len9; s++) {
                course = courses[s];
                if (course.field === "PHYS" && course.number === 332 && !course.deprecated) {
                  this.exclusions.push(course);
                  matched = true;
                }
              }
            } else {
// This is normal PHYS 332, so exclude the legacy version
              for (u = 0, len10 = courses.length; u < len10; u++) {
                course = courses[u];
                if (course.field === "PHYS" && course.number === 332 && course.deprecated) {
                  this.exclusions.push(course);
                  matched = true;
                }
              }
            }
          }
        }
        if (!matched) {
          results.push((function() {
            var len11, results1, v;
            results1 = [];
            for (v = 0, len11 = courses.length; v < len11; v++) {
              course = courses[v];
              basic_match = `${course.field} ${course.number}` === designation;
              name_match = course.name === designation || course.name.includes(designation);
              if (basic_match || name_match) {
                this.exclusions.push(course);
                results1.push(matched = true);
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    // find courses that have this course as a direct dependence
    downstream(courses) {
      var course, j, len, res;
      res = [];
      for (j = 0, len = courses.length; j < len; j++) {
        course = courses[j];
        if (course.prereqs.includes(this) || course.coreqs.includes(this)) {
          res.push(course);
        }
      }
      return res;
    }

    available(year_term) {
      var combo_count, combo_option, coreq, course, current_term_value, excluded_state, first_offered_value, j, k, l, last_offered_value, len, len1, len2, len3, len4, m, n, option, option_completed, prereq, ref, ref1, ref2, ref3, ref4, res, term, term_value, year;
      year = year_term.year;
      term = year_term.term;
      
      // Helper function to compare terms (spring comes before fall in the same year)
      term_value = function(y, t) {
        var value;
        value = y * 10;
        value += t === 'fall' ? 5 : 0;
        return value;
      };
      current_term_value = term_value(year, term);
      
      // Check if course is available during the given term
      // If the course is scheduled for the future, it's not available now
      if ((this.first_offered_year != null) && (this.first_offered_term != null)) {
        first_offered_value = term_value(this.first_offered_year, this.first_offered_term);
        if (current_term_value < first_offered_value) {
          return false;
        }
      }
      
      // If the course is deprecated, check if we've passed its last offering
      if (this.deprecated && (this.last_offered_year != null) && (this.last_offered_term != null)) {
        last_offered_value = term_value(this.last_offered_year, this.last_offered_term);
        if (current_term_value > last_offered_value) {
          return false;
        }
      }
      
      // Check prerequisites, corequisites, etc.
      res = true;
      ref = this.prereqs;
      for (j = 0, len = ref.length; j < len; j++) {
        prereq = ref[j];
        res = res && prereq.completed;
      }
      ref1 = this.coreqs;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        coreq = ref1[k];
        res = res && (coreq.completed || coreq.enrolling);
      }
      // handle course with a minimum number of prerequisites from a collection
      // of courses
      combo_count = 0;
      ref2 = this.combo_options;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        combo_option = ref2[l];
        if (combo_option.completed) {
          combo_count += 1;
        }
      }
      res = res && (combo_count >= this.combo_option_min);
      
      // handle options - at least one option must be completed
      if (this.options.length > 0) {
        option_completed = false;
        ref3 = this.options;
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          option = ref3[m];
          if (option.completed) {
            option_completed = true;
            break;
          }
        }
        res = res && option_completed;
      }
      ref4 = this.exclusions;
      // handle courses that exclude other courses (ex. 356 & 365)  
      for (n = 0, len4 = ref4.length; n < len4; n++) {
        course = ref4[n];
        excluded_state = course.completed || course.enrolling;
        res = res && !excluded_state;
      }
      // offered this year?
      res = res && ((this.years_offered === 'all') || ((this.years_offered === 'even') && (year % 2 === 0)) || ((this.years_offered === 'odd') && (year % 2 === 1)));
      // offered this term?
      res = res && ((this.terms_offered === 'all') || this.terms_offered === term);
      return res;
    }

    clear_formatting() {
      $(this.card_sel).removeClass(this.all_border_classes);
      $(this.header_sel).removeClass(this.all_bg_classes);
      $(this.header_sel).removeClass('text-white font-weight-bold');
      $(this.modal_sel).removeClass(this.all_btn_classes);
      // Remove shadow effect
      $(this.card_sel).css('box-shadow', '');
      // Also remove any badges
      return $(this.header_sel + " span.badge").remove();
    }

    // $(@modal_sel).addClass('btn-secondary')
    update_badge() {
      // Ensure there are no existing badges first
      $(this.header_sel + " span.badge").remove();
      
      // Add the appropriate badge if needed
      if (this.deprecated && (this.last_offered_year != null) && (this.last_offered_term != null)) {
        return $(this.header_sel).append(" <span class='badge badge-danger'>Discontinued</span>");
      } else if ((this.first_offered_year != null) && (this.first_offered_term != null)) {
        return $(this.header_sel).append(` <span class='badge badge-info'>Coming ${this.first_offered_term} ${this.first_offered_year}</span>`);
      }
    }

    mark_available(degree_plan) {
      this.completed = false;
      this.year_term_taken = false;
      this.enrolling = false;
      this.clear_formatting();
      if (degree_plan) {
        if (degree_plan.required(this)) {
          $(this.card_sel).addClass('border-thick');
          $(this.header_sel).addClass('font-weight-bold');
          // Add shadow to required and available courses
          $(this.card_sel).css('box-shadow', '0 6px 12px rgba(0,0,0,0.5)');
        }
      }
      $(this.card_sel).addClass('border-warning');
      $(this.header_sel).addClass('bg-warning text-white');
      $(this.completed_sel).prop('disabled', false);
      $(this.enrolling_sel).prop('disabled', false);
      $(this.completed_sel).prop('checked', false);
      $(this.enrolling_sel).prop('checked', false);
      $(this.modal_sel).addClass('btn-warning');
      
      // Add visual indicator for future courses
      return this.update_badge();
    }

    mark_unavailable(degree_plan) {
      this.completed = false;
      this.year_term_taken = false;
      this.enrolling = false;
      this.clear_formatting();
      if (degree_plan) {
        if (degree_plan.required(this)) {
          $(this.card_sel).addClass('border-thick');
          $(this.header_sel).addClass('font-weight-bold');
        }
      }
      $(this.card_sel).addClass('border-secondary');
      $(this.completed_sel).prop('disabled', false);
      $(this.enrolling_sel).prop('disabled', true);
      $(this.completed_sel).prop('checked', false);
      $(this.enrolling_sel).prop('checked', false);
      
      // Always add btn-secondary regardless of whether course is deprecated or future
      $(this.modal_sel).addClass('btn-secondary');
      
      // Add visual indicator for deprecated or future courses
      return this.update_badge();
    }

    mark_completed(year_term, degree_plan) {
      var course, j, k, l, len, len1, len2, ref, ref1, ref2, results;
      this.completed = true;
      this.year_term_taken = year_term;
      this.enrolling = false;
      this.clear_formatting();
      if (degree_plan) {
        if (degree_plan.required(this)) {
          $(this.card_sel).addClass('border-thick');
          $(this.header_sel).addClass('font-weight-bold');
        }
      }
      $(this.card_sel).addClass('border-success');
      $(this.header_sel).addClass('bg-success text-white');
      $(this.completed_sel).prop('checked', true);
      $(this.enrolling_sel).prop('checked', false);
      $(this.completed_sel).prop('disabled', false);
      $(this.enrolling_sel).prop('disabled', true);
      $(this.modal_sel).addClass('btn-success');
      ref = this.prereqs;
      for (j = 0, len = ref.length; j < len; j++) {
        course = ref[j];
        if (!(course.completed && course.year_term_taken)) {
          course.mark_completed(year_term, degree_plan);
        }
      }
      ref1 = this.coreqs;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        course = ref1[k];
        if (!(course.completed && course.year_term_taken)) {
          course.mark_completed(year_term, degree_plan);
        }
      }
      ref2 = this.downstream(courses);
      // make sure that upstream courses know about the changes. You'd think
      // that refresh would handle this, but it seems it doesn't, at least in the
      // case where marking something complete would make its prerequsities be
      // complete, but then courses downstream from those prerequisites would NOT
      // get marked complete. This appears to fix the problem.
      results = [];
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        course = ref2[l];
        results.push(course.refresh(year_term, year_term, degree_plan));
      }
      return results;
    }

    mark_enrolling(year_term, degree_plan) {
      this.completed = false;
      this.year_term_taken = year_term;
      this.enrolling = true;
      this.clear_formatting();
      if (degree_plan) {
        if (degree_plan.required(this)) {
          $(this.card_sel).addClass('border-thick');
          $(this.header_sel).addClass('font-weight-bold');
        }
      }
      $(this.card_sel).addClass('border-primary');
      $(this.header_sel).addClass('bg-primary text-white');
      $(this.completed_sel).prop('checked', false);
      $(this.enrolling_sel).prop('checked', true);
      $(this.completed_sel).prop('disabled', true);
      $(this.enrolling_sel).prop('disabled', false);
      return $(this.modal_sel).addClass('btn-primary');
    }

    refresh(old_year_term, new_year_term, degree_plan) {
      // moving to future year? convert class from enrolling to taken
      if (new_year_term.value() > old_year_term.value()) {
        if (this.enrolling) {
          this.mark_completed(old_year_term, degree_plan);
          $(this.enrolling_sel).prop('checked', this.enrolling);
          return $(this.completed_sel).prop('checked', this.completed);
        } else if (this.completed) {
          if (new_year_term.value() > this.year_term_taken.value()) {
            return this.mark_completed(this.year_term_taken, degree_plan);
          }
        } else if (this.available(new_year_term)) {
          return this.mark_available(degree_plan);
        } else {
          return this.mark_unavailable(degree_plan);
        }
      
      // staying in the same year-term (changed status of one course)
      } else if (new_year_term.value() === old_year_term.value()) {
        if (this.completed) {
          if (!this.year_term_taken) {
            // probably just marked completed; pretend it was taken the term
            // before it was marked completed
            return this.mark_completed(old_year_term.prev(), degree_plan);
          } else {
            return this.mark_completed(this.year_term_taken, degree_plan);
          }
        } else if (this.enrolling) {
          return this.mark_enrolling(new_year_term, degree_plan);
        } else if (this.available(new_year_term)) {
          return this.mark_available(degree_plan);
        } else {
          return this.mark_unavailable(degree_plan);
        }
      } else {
        // going back in time; might need to unset date taken
        if (this.completed) {
          if (new_year_term.value() > this.year_term_taken.value()) {
            return this.mark_completed(this.year_term_taken, degree_plan);
          } else if (new_year_term.value() === this.year_term_taken.value()) {
            return this.mark_enrolling(this.year_term_taken, degree_plan);
          } else if (this.available(new_year_term)) {
            return this.mark_available(degree_plan);
          } else {
            return this.mark_unavailable(degree_plan);
          }
        // not completed, but it was marked enrolling? Then it isn't taken or
        // enrolled. Pretend it it never happened
        } else if (this.available(new_year_term)) {
          return this.mark_available(degree_plan);
        } else {
          return this.mark_unavailable(degree_plan);
        }
      }
    }

  };

  DegreePlan = class DegreePlan {
    constructor(degree_plan_info) {
      var class_name, combo, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, new_combo, new_sequence, o, p, q, r, ref, ref1, ref2, ref3, ref4, sequence;
      this.degree_plan_info = degree_plan_info;
      this.name = this.degree_plan_info.name;
      this.credits_needed = this.degree_plan_info.credits_needed;
      this.counted_classes = {
        requirements: [],
        choices: []
      };
      this.uncounted_classes = {
        requirements: [],
        choices: []
      };
      this.extra_electives = [];
      this.course_groups = this.degree_plan_info.course_groups;
      // track class objects in the various requirements, rather than just class
      // designations
      if (this.degree_plan_info.counted !== void 0) {
        if (this.degree_plan_info.counted.requirements !== void 0) {
          ref = this.degree_plan_info.counted.requirements;
          for (j = 0, len = ref.length; j < len; j++) {
            class_name = ref[j];
            this.counted_classes.requirements.push(get_course(class_name));
          }
        }
        if (this.degree_plan_info.counted.choices !== void 0) {
          ref1 = this.degree_plan_info.counted.choices;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            combo = ref1[k];
            new_combo = [];
            for (l = 0, len2 = combo.length; l < len2; l++) {
              sequence = combo[l];
              new_sequence = [];
              for (m = 0, len3 = sequence.length; m < len3; m++) {
                class_name = sequence[m];
                new_sequence.push(get_course(class_name));
              }
              new_combo.push(new_sequence);
            }
            this.counted_classes.choices.push(new_combo);
          }
        }
      }
      if (this.degree_plan_info.uncounted !== void 0) {
        if (this.degree_plan_info.uncounted.requirements !== void 0) {
          ref2 = this.degree_plan_info.uncounted.requirements;
          for (n = 0, len4 = ref2.length; n < len4; n++) {
            class_name = ref2[n];
            this.uncounted_classes.requirements.push(get_course(class_name));
          }
        }
        if (this.degree_plan_info.uncounted.choices !== void 0) {
          ref3 = this.degree_plan_info.uncounted.choices;
          for (o = 0, len5 = ref3.length; o < len5; o++) {
            combo = ref3[o];
            new_combo = [];
            for (p = 0, len6 = combo.length; p < len6; p++) {
              sequence = combo[p];
              new_sequence = [];
              for (q = 0, len7 = sequence.length; q < len7; q++) {
                class_name = sequence[q];
                new_sequence.push(get_course(class_name));
              }
              new_combo.push(new_sequence);
            }
            this.uncounted_classes.choices.push(new_combo);
          }
        }
      }
      if (this.degree_plan_info.extra_electives !== void 0) {
        ref4 = this.degree_plan_info.extra_electives;
        for (r = 0, len8 = ref4.length; r < len8; r++) {
          class_name = ref4[r];
          this.extra_electives.push(get_course(class_name));
        }
      }
    }

    // determine if a course sequence (part of a combination of possible options)
    // is "complete". It's considered complete when all courses are already
    // completed OR ENROLLED (which may be counterintuitive, but this lets us
    // mark other sequences as not required anymore)
    sequence_completed(sequence) {
      var course, j, len, res;
      res = true;
      for (j = 0, len = sequence.length; j < len; j++) {
        course = sequence[j];
        res = res && (course.completed || course.enrolling);
      }
      return res;
    }

    // determine if a course is "required". We interpret this to be if the class
    // is simply a required course, or it is part of a sequence of courses
    // comprising one possibility in a combination option. Note that partially-
    // completed sequences will still courses in OTHER sequences in the same combo
    // to appear as required.
    required(course) {
      var combo, j, k, l, len, len1, len2, len3, m, ref, ref1, sequence;
      // first check required courses (simple)
      if (this.counted_classes.requirements.includes(course)) {
        return true;
      } else if (this.uncounted_classes.requirements.includes(course)) {
        return true;
      } else if (!(this.counted_classes.choices.flat(4).includes(course) || this.uncounted_classes.choices.flat(4).includes(course))) {
        return false;
      // Crap. It's a class in a series of choices, so we need to figure out
      // if another option has already been completed.
      } else if (this.counted_classes.choices.flat(4).includes(course)) {
        ref = this.counted_classes.choices;
        // each "combo" is really a collection of course sequences (each of which
        // may only contain one course). The points is there could be a
        // requirement to take one of classes A, B, and C, AND there could be
        // an additional requirement that someone take both D and E, or just F.
        // In this example, [A], [B], and [C] represent a combination of
        // sequences, each of length 1.
        for (j = 0, len = ref.length; j < len; j++) {
          combo = ref[j];
          // don't consider combination of sequences if course doesn't appear
          if (!combo.flat(3).includes(course)) {
            continue;
          }
// bail out if any one sequence is completed; this class isn't needed
          for (k = 0, len1 = combo.length; k < len1; k++) {
            sequence = combo[k];
            // skip the sequence if the class appears in it (it might be complete,
            // but our convention is that completed courses can still be
            // "required")
            if (sequence.flat(2).includes(course)) {
              continue;
            }
            if (this.sequence_completed(sequence)) {
              return false;
            }
          }
        }
        return true;
      } else if (this.uncounted_classes.choices.flat(4).includes(course)) {
        ref1 = this.uncounted_classes.choices;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          combo = ref1[l];
          // don't consider combination of sequences if course doesn't appear
          if (!combo.flat(3).includes(course)) {
            continue;
          }
// bail out if any one sequence is completed
          for (m = 0, len3 = combo.length; m < len3; m++) {
            sequence = combo[m];
            // skip the sequence if the class appears in it (it might be complete,
            // but our convention is that completed courses can still be
            // "required")
            if (sequence.flat(2).includes(course)) {
              continue;
            }
            if (this.sequence_completed(sequence)) {
              return false;
            }
          }
        }
        return true;
      }
    }

    // Check if all required courses are completed
    all_required_courses_complete() {
      var combo, combo_satisfied, course, j, k, l, len, len1, len2, ref, ref1, sequence;
      ref = this.counted_classes.requirements;
      // Check all required courses
      for (j = 0, len = ref.length; j < len; j++) {
        course = ref[j];
        if (!course.completed && !course.enrolling) {
          return false;
        }
      }
      ref1 = this.counted_classes.choices;
      
      // Check all course choices (need at least one complete from each combo)
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        combo = ref1[k];
        combo_satisfied = false;

        // A combo is satisfied if at least one sequence is complete
        for (l = 0, len2 = combo.length; l < len2; l++) {
          sequence = combo[l];
          if (this.sequence_completed(sequence)) {
            combo_satisfied = true;
            break;
          }
        }
        if (!combo_satisfied) {
          return false;
        }
      }
      
      // All requirements are met
      return true;
    }

    
      // compute how many credits count towards the degree requirement
    credit_count() {
      var course, credit_count, j, len;
      credit_count = 0;
      for (j = 0, len = courses.length; j < len; j++) {
        course = courses[j];
        if (course.completed || course.enrolling) {
          // is course explicitly a requirement, choice, or explicit elective?
          if (this.counted_classes.requirements.includes(course) || this.counted_classes.choices.flat(3).includes(course) || this.extra_electives.includes(course)) {
            credit_count += course.credits;
          // is course an implicit elective (PHYS class numbered over 325)
          } else if (course.field === 'PHYS' && course.number > 325) {
            credit_count += course.credits;
          }
        }
      }
      return credit_count;
    }

  };

  YearTerm = class YearTerm {
    constructor(year1, term1) {
      this.year = year1;
      this.term = term1;
    }

    value() {
      var res;
      res = this.year * 10;
      if (this.term === 'fall') {
        res += 5;
      }
      return res;
    }

    prev() {
      var new_term, new_year;
      new_term = 'fall';
      new_year = this.year;
      if (this.term === 'fall') {
        new_term = 'spring';
      } else {
        new_year -= 1;
      }
      return new YearTerm(new_year, new_term);
    }

    next() {
      var new_term, new_year;
      new_term = 'fall';
      new_year = this.year;
      if (this.term === 'fall') {
        new_term = 'spring';
        new_year += 1;
      }
      return new YearTerm(new_year, new_term);
    }

    toString() {
      return `${this.term.replace(/^\w/, (c) => {
        return c.toUpperCase();
      })} ${this.year}`;
    }

  };

  
  // combine course data with the course class to make useful objects
  MATH_112 = new Course(course_data.MATH_112);

  MATH_114 = new Course(course_data.MATH_114);

  MATH_215 = new Course(course_data.MATH_215);

  MATH_216 = new Course(course_data.MATH_216);

  MATH_312 = new Course(course_data.MATH_312);

  MATH_345 = new Course(course_data.MATH_345);

  CHEM_105 = new Course(course_data.CHEM_105);

  CHEM_106 = new Course(course_data.CHEM_106);

  CHEM_109 = new Course(course_data.CHEM_109);

  CHEM_115 = new Course(course_data.CHEM_115);

  MSE_120 = new Course(course_data.MSE_120);

  MSE_221 = new Course(course_data.MSE_221);

  MSE_350 = new Course(course_data.MSE_350);

  MSE_374 = new Course(course_data.MSE_374);

  MSE_315 = new Course(course_data.MSE_315);

  MSE_357 = new Course(course_data.MSE_357);

  MSE_372 = new Course(course_data.MSE_372);

  MSE_451 = new Course(course_data.MSE_451);

  PHYS_115 = new Course(course_data.PHYS_115);

  PHYS_186 = new Course(course_data.PHYS_186);

  // PHYS_205 = new Course(course_data.PHYS_205)
  PHYS_226 = new Course(course_data.PHYS_226);

  PHYS_229 = new Course(course_data.PHYS_229);

  PHYS_231 = new Course(course_data.PHYS_231);

  PHYS_232 = new Course(course_data.PHYS_232);

  PHYS_240 = new Course(course_data.PHYS_240);

  PHYS_255 = new Course(course_data.PHYS_255);

  PHYS_308 = new Course(course_data.PHYS_308);

  PHYS_315 = new Course(course_data.PHYS_315);

  PHYS_332_legacy = new Course(course_data.PHYS_332_legacy);

  PHYS_332 = new Course(course_data.PHYS_332);

  PHYS_333 = new Course(course_data.PHYS_333);

  PHYS_340 = new Course(course_data.PHYS_340);

  PHYS_350 = new Course(course_data.PHYS_350);

  PHYS_356 = new Course(course_data.PHYS_356);

  PHYS_360 = new Course(course_data.PHYS_360);

  // PHYS_361 = new Course(course_data.PHYS_361)
  // PHYS_362 = new Course(course_data.PHYS_362)
  // PHYS_363 = new Course(course_data.PHYS_363)
  PHYS_365 = new Course(course_data.PHYS_365);

  PHYS_367 = new Course(course_data.PHYS_367);

  PHYS_375 = new Course(course_data.PHYS_375);

  PHYS_415 = new Course(course_data.PHYS_415);

  PHYS_430 = new Course(course_data.PHYS_430);

  PHYS_445 = new Course(course_data.PHYS_445);

  PHYS_465 = new Course(course_data.PHYS_465);

  PHYS_486 = new Course(course_data.PHYS_486);

  /* IMPORTANT GLOBAL VARIABLE */
  // This lists all the coures objects and is used in several classes, which
  // is terrible form, but hey, it works! Well, usually... The order is important.
  // When cycling through the courses, its best if prerequisites come before
  // the courses they depend on. So math courses should always go first, and then
  // mostly courses can simply increase in number. However, care must be taken to
  // ensure that some MSE courses are in the right place. For instance, MSE 451
  // depends on PHYS 333, but if it comes before PHYS 333, completing PHYS 333
  // will not immediately cause PHYS 451 to be marked as available because it is
  // refreshed *before* PHYS 333 since it's earlier on the list.

  // Fall 2022: Removed PHYS 205, 361, 362, and 363
  // Spring 2025: Added (deprecated) PHYS_332_legacy, deprecated PHYS 333 and
  // PHYS 465, updated PHYS 332
  courses = [MATH_112, MATH_114, MATH_215, MATH_216, MATH_312, MATH_345, CHEM_105, CHEM_106, CHEM_109, CHEM_115, PHYS_115, PHYS_186, PHYS_226, PHYS_229, PHYS_231, PHYS_232, PHYS_240, PHYS_255, PHYS_308, PHYS_315, PHYS_332, PHYS_332_legacy, PHYS_333, PHYS_340, PHYS_350, PHYS_356, PHYS_360, PHYS_365, PHYS_367, PHYS_375, PHYS_415, PHYS_430, PHYS_445, PHYS_465, PHYS_486, MSE_120, MSE_315, MSE_221, MSE_350, MSE_357, MSE_372, MSE_374, MSE_451];

// firm up requirements so they work properly
  for (j = 0, len = courses.length; j < len; j++) {
    course = courses[j];
    course.update_requirements(courses);
  }

  // Fall 2022: Removed PHYS 205, 361, 362, and 363, which were electives or required
  // courses in each degree plan. PHYS 205 was a "basic elective" for the minor
  // and appeared nowhere else
  // Spring 2025: Added (deprecated) PHYS_332_legacy, deprecated PHYS 333 and
  // PHYS 465, updated PHYS 332. Added PHYS 415.
  degree_plan_data = [
    {
      name: 'Liberal Arts',
      credits_needed: 36,
      counted: {
        requirements: ['PHYS 186',
    'PHYS 231',
    'PHYS 232',
    'PHYS 350',
    'PHYS 365',
    'PHYS 486'],
        choices: [[['PHYS 340'],
    ['PHYS 360']],
    [['PHYS 332'],
    ['PHYS 332 legacy']]]
      },
      uncounted: {
        requirements: ['MATH 312',
    'PHYS 240'],
        choices: []
      },
      extra_electives: ['MSE 374',
    'MSE 357',
    'MSE 372',
    'MSE 451'],
      course_groups: [
        {
          title: 'Introductory and Prerequisite Courses',
          courses: [MATH_112,
        MATH_114,
        MATH_215,
        MATH_216,
        PHYS_186,
        PHYS_231,
        PHYS_232,
        PHYS_240]
        },
        {
          title: 'Intermediate Courses',
          courses: [MATH_312,
        PHYS_332,
        PHYS_332_legacy,
        PHYS_333,
        PHYS_340,
        PHYS_350,
        PHYS_365]
        },
        {
          title: 'Advanced Courses',
          courses: [PHYS_360,
        PHYS_486]
        },
        {
          title: 'Electives',
          courses: [PHYS_367,
        PHYS_375,
        PHYS_415,
        PHYS_430,
        PHYS_445,
        PHYS_465,
        MSE_315,
        MSE_357,
        MSE_372,
        MSE_374,
        MSE_451]
        },
        {
          title: 'Elective Support (uncounted towards major)',
          courses: [CHEM_105,
        CHEM_106,
        CHEM_109,
        CHEM_115,
        MSE_221,
        MSE_350]
        }
      ]
    },
    {
      name: 'Applied',
      credits_needed: 36,
      counted: {
        requirements: ['PHYS 231',
    'PHYS 232',
    'PHYS 340',
    'PHYS 350',
    'PHYS 360',
    'PHYS 430',
    'PHYS 486'],
        choices: [[['PHYS 186'],
    ['MSE 120']],
    [['PHYS 255',
    'PHYS 356'],
    ['PHYS 365'],
    ['PHYS 375']],
    [['PHYS 332 legacy'],
    ['PHYS 332']]]
      },
      uncounted: {
        requirements: ['MATH 312',
    'MATH 345',
    'PHYS 240'],
        choices: [[['CHEM 115'],
    ['CHEM 105',
    'CHEM 106',
    'CHEM 109']]]
      },
      extra_electives: ['MSE 374',
    'MSE 357',
    'MSE 372',
    'MSE 451'],
      course_groups: [
        {
          title: 'Introductory and Prerequisite Courses',
          courses: [MATH_112,
        MATH_114,
        MATH_215,
        MATH_216,
        PHYS_186,
        MSE_120,
        PHYS_231,
        PHYS_232,
        PHYS_240,
        CHEM_105,
        CHEM_106,
        CHEM_109,
        CHEM_115]
        },
        {
          title: 'Intermediate Courses',
          courses: [MATH_312,
        MATH_345,
        PHYS_255,
        PHYS_332,
        PHYS_332_legacy,
        PHYS_340,
        PHYS_350,
        PHYS_365]
        },
        {
          title: 'Advanced Courses',
          courses: [PHYS_356,
        PHYS_360,
        PHYS_375,
        PHYS_430,
        PHYS_486]
        },
        {
          title: 'Electives',
          courses: [PHYS_333,
        PHYS_367,
        PHYS_415,
        PHYS_445,
        PHYS_465,
        MSE_315,
        MSE_357,
        MSE_372,
        MSE_374,
        MSE_451]
        },
        {
          title: 'Elective Support (uncounted towards major)',
          courses: [MSE_221,
        MSE_350]
        }
      ]
    },
    {
      name: 'Astrophysics',
      credits_needed: 36,
      counted: {
        requirements: ['PHYS 186',
    'PHYS 231',
    'PHYS 232',
    'PHYS 332',
    'PHYS 340',
    'PHYS 365',
    'PHYS 367',
    'PHYS 430',
    'PHYS 486'],
        choices: [[['PHYS 226'],
    ['PHYS 229']],
    [['PHYS 375'],
    ['PHYS 415'],
    ['PHYS 445'],
    ['PHYS 465']],
    [['PHYS 332 legacy'],
    ['PHYS 332']]]
      },
      uncounted: {
        requirements: ['MATH 312',
    'PHYS 240'],
        choices: []
      },
      extra_electives: [],
      course_groups: [
        {
          title: 'Introductory and Prerequisite Courses',
          courses: [MATH_112,
        MATH_114,
        MATH_215,
        MATH_216,
        PHYS_186,
        PHYS_226,
        PHYS_229,
        PHYS_231,
        PHYS_232,
        PHYS_240]
        },
        {
          title: 'Intermediate Courses',
          courses: [MATH_312,
        PHYS_332,
        PHYS_332_legacy,
        PHYS_333,
        PHYS_340,
        PHYS_367]
        },
        {
          title: 'Advanced Courses',
          courses: [PHYS_365,
        PHYS_375,
        PHYS_415,
        PHYS_430,
        PHYS_445,
        PHYS_465,
        PHYS_486]
        },
        {
          title: 'Electives (not needed for credit towards major)',
          courses: [PHYS_350,
        PHYS_360]
        }
      ]
    },
    {
      name: 'Dual Degree',
      credits_needed: 36,
      counted: {
        requirements: ['MSE 120',
    'PHYS 231',
    'PHYS 232',
    'PHYS 332',
    'PHYS 340',
    'PHYS 350'],
        choices: [[['PHYS 255',
    'PHYS 356'],
    ['PHYS 365']],
    [['PHYS 332'],
    ['PHYS 332 legacy']]]
      },
      uncounted: {
        requirements: ['MATH 312',
    'PHYS 240'],
        choices: []
      },
      extra_electives: ['MSE 374',
    'MSE 357',
    'MSE 372',
    'MSE 451'],
      course_groups: [
        {
          title: 'Introductory and Prerequisite Courses',
          courses: [MATH_112,
        MATH_114,
        MATH_215,
        MATH_216,
        MSE_120,
        PHYS_231,
        PHYS_232,
        PHYS_240]
        },
        {
          title: 'Intermediate Courses',
          courses: [MATH_312,
        PHYS_255,
        PHYS_332,
        PHYS_332_legacy,
        PHYS_340,
        PHYS_350,
        PHYS_365]
        },
        {
          title: 'Advanced Courses',
          courses: [PHYS_356]
        },
        {
          title: 'Electives',
          courses: [PHYS_333,
        PHYS_360,
        PHYS_367,
        PHYS_375,
        PHYS_415,
        PHYS_430,
        PHYS_445,
        PHYS_465,
        MSE_374,
        MSE_357,
        MSE_372,
        MSE_451]
        },
        {
          title: 'Elective Support (uncounted towards major)',
          courses: [CHEM_105,
        CHEM_106,
        CHEM_109,
        CHEM_115,
        MSE_221,
        MSE_350]
        }
      ]
    },
    {
      name: 'Minor',
      credits_needed: 24,
      counted: {
        requirements: ['PHYS 231',
    'PHYS 232'],
        choices: [[['PHYS 332'],
    ['PHYS 332 legacy']]]
      },
      uncounted: {
        requirements: ['MATH 215'],
        choices: []
      },
      extra_electives: [
        'PHYS 115',
        'PHYS 186',
        'PHYS 226', //, 'PHYS 205'
        'PHYS 229',
        'PHYS 240',
        'PHYS 308',
        'PHYS 315'
      ],
      course_groups: [
        {
          title: 'Prerequisite Courses',
          courses: [MATH_112,
        MATH_114,
        MATH_215]
        },
        {
          title: 'Required Courses',
          courses: [PHYS_231,
        PHYS_232,
        PHYS_332,
        PHYS_332_legacy]
        },
        {
          title: 'Basic Electives',
          courses: [PHYS_115,
        PHYS_186,
        PHYS_226,
        PHYS_229,
        PHYS_240,
        PHYS_308,
        PHYS_315]
        },
        {
          title: 'Advanced Electives',
          courses: [PHYS_333,
        PHYS_340,
        PHYS_350,
        PHYS_356,
        PHYS_360,
        PHYS_365,
        PHYS_367,
        PHYS_375,
        PHYS_415,
        PHYS_430,
        PHYS_445,
        PHYS_465,
        PHYS_486]
        }
      ]
    }
  ];

  // obsolete_degree_plans = [
  //   {
  //     name: 'LabVIEW'
  //     credits_needed: 13
  //     counted:
  //       requirements: ['PHYS 350', 'PHYS 360', 'PHYS 361', 'PHYS 362', 'PHYS 363']
  //       choices: []
  //     uncounted:
  //       requirements: []
  //       choices: []
  //     course_groups: [
  //       {
  //         title: 'Introductory and Prerequisite Courses'
  //         courses: [MATH_112, MATH_114, MATH_215, PHYS_231, PHYS_232, PHYS_240]
  //       },
  //       {
  //         title: 'Certificate Courses'
  //         courses: [PHYS_350, PHYS_360, PHYS_361, PHYS_362, PHYS_363]
  //       },
  //     ]
  //   }
  // ]
  get_course = function(designation) {
    var field, is_looking_for_deprecated, k, l, len1, len2, len3, m, number, term;
    // Parse the field and number from the designation
    field = designation.split(' ')[0];
    number = Number(designation.split(' ')[1]);
    is_looking_for_deprecated = false;

    // First check if the designation contains any deprecated terms
    for (k = 0, len1 = deprecated_synonyms.length; k < len1; k++) {
      term = deprecated_synonyms[k];
      is_looking_for_deprecated = is_looking_for_deprecated || designation.toLowerCase().includes(term);
    }
    
    // Handle special case for PHYS 332
    if (field === 'PHYS' && number === 332) {
      
      // If specifically asking for legacy/deprecated version
      if (is_looking_for_deprecated) {
        return PHYS_332_legacy;
      }
      
      // If asking for regular version (or unspecified)
      return PHYS_332;
    }

    // For all other courses, check if we're looking for a deprecated version  
// First try to find an exact match with the deprecated status
    for (l = 0, len2 = courses.length; l < len2; l++) {
      course = courses[l];
      if (course.field === field && course.number === number && course.deprecated === is_looking_for_deprecated) {
        return course;
      }
    }

    // If no exact match found, just match on field and number
    for (m = 0, len3 = courses.length; m < len3; m++) {
      course = courses[m];
      if (course.field === field && course.number === number) {
        return course;
      }
    }
    return console.error(`No course found for: ${designation}`);
  };

  // Find a course object from an HTML element ID
  // This handles IDs with suffixes like "_legacy"
  get_course_from_element_id = function(element_id) {
    var base_number, course_name, field, has_legacy_suffix, k, len1, number_with_suffix, parts;
    // Split the ID by dashes
    parts = element_id.split('-');
    
    // Extract the field name and number
    if (parts.length >= 2) {
      field = parts[0];
      number_with_suffix = parts[1];
      
      // Check if there's a suffix like "_legacy"
      has_legacy_suffix = number_with_suffix.includes('_');
      
      // For PHYS 332, we need special handling due to multiple versions
      if (field === "PHYS" && number_with_suffix.startsWith("332")) {
        if (has_legacy_suffix && number_with_suffix.includes("_legacy")) {
          // This is the legacy version
          return PHYS_332_legacy;
        } else if (number_with_suffix === "332") {
          // This is the new version
          return PHYS_332;
        }
      }
      
      // For other courses or if PHYS 332 wasn't matched
      if (has_legacy_suffix) {
        // Extract the base number without suffix
        base_number = number_with_suffix.split('_')[0];
// Look up with legacy flag
        for (k = 0, len1 = courses.length; k < len1; k++) {
          course = courses[k];
          if (course.field === field && course.number.toString() === base_number && course.deprecated) {
            return course;
          }
        }
      }
      
      // Fall back to standard lookup if all else fails
      course_name = `${field} ${number_with_suffix.split('_')[0]}`;
      course = get_course(course_name);
      return course;
    }
    
    // If we couldn't parse the ID, log an error and return null
    console.error(`Could not parse element ID: ${element_id}`);
    return null;
  };

  // set up degree plans
  degree_plans = degree_plan_data.map(function(dpd) {
    return new DegreePlan(dpd);
  });

  get_degree_plan = function(plan_name) {
    var dp, k, len1;
    for (k = 0, len1 = degree_plans.length; k < len1; k++) {
      dp = degree_plans[k];
      if (dp.name === plan_name) {
        return dp;
      }
    }
  };

  // compute counted credits towards the degree
  today = new Date();

  current_year = today.getFullYear();

  current_month = today.getMonth();

  first_term = 'fall';

  second_term = 'spring';

  year_terms = [new YearTerm(current_year, 'spring'), new YearTerm(current_year, 'fall'), new YearTerm(current_year + 1, 'spring'), new YearTerm(current_year + 1, 'fall'), new YearTerm(current_year + 2, 'spring'), new YearTerm(current_year + 2, 'fall'), new YearTerm(current_year + 3, 'spring'), new YearTerm(current_year + 3, 'fall'), new YearTerm(current_year + 4, 'spring'), new YearTerm(current_year + 4, 'fall'), new YearTerm(current_year + 5, 'spring'), new YearTerm(current_year + 5, 'fall'), new YearTerm(current_year + 6, 'spring')];

  if (current_month < 5) {
    year_terms = year_terms.slice(0, 12);
  } else {
    year_terms = year_terms.slice(1, 13);
  }

  // Fall 2022: Removed PHYS 361, PHYS 362, and PHYS 363, which were "Intermediate
  // Courses". Actually, only PHYS 361 was. PHYS 362 and PHYS 363 didn't appear.
  wizard = {
    year_term: year_terms[0],
    degree_plan: degree_plans[0],
    course_groups: [
      {
        title: 'Introductory and Prerequisite Courses',
        courses: [MATH_112,
      MATH_114,
      MATH_215,
      MATH_216,
      PHYS_186,
      PHYS_231,
      PHYS_232,
      PHYS_240]
      },
      {
        title: 'Intermediate Courses',
        courses: [MATH_312,
      PHYS_255,
      PHYS_332,
      PHYS_332_legacy,
      PHYS_333,
      PHYS_340,
      PHYS_350,
      PHYS_365]
      },
      {
        title: 'Advanced Courses',
        courses: [PHYS_356,
      PHYS_360,
      PHYS_367,
      PHYS_375,
      PHYS_430,
      PHYS_445,
      PHYS_465,
      PHYS_486]
      },
      {
        title: 'Other Courses',
        courses: [CHEM_105,
      CHEM_106,
      CHEM_109,
      CHEM_115,
      MATH_345]
      }
    ],
    clear_groups: function() {
      return $('#body').html('');
    },
    add_group: function(new_group) {
      var k, len1, ref, to_add;
      to_add = "<hr class='my-4'>\n";
      to_add += "<div class='row'><div class='col'>\n";
      to_add += `  <h2>${new_group.title}</h2>\n`;
      to_add += "</div></div>\n";
      to_add += "<div class='row'>\n";
      ref = new_group.courses;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        course = ref[k];
        to_add += "  <div class='col-12 col-md-6 col-lg-4 col-xl-3 mb-3'>\n";
        to_add += `    ${course.html_card}`;
        to_add += "  </div>\n";
      }
      to_add += "</div>\n";
      return $('#body').append(to_add);
    },
    refresh: function(old_year_term) {
      var credit_count, k, len1, required_complete;
      for (k = 0, len1 = courses.length; k < len1; k++) {
        course = courses[k];
        course.refresh(old_year_term, wizard.year_term, wizard.degree_plan);
      }
      // update credit count display
      credit_count = wizard.degree_plan.credit_count();
      $('#credit_count').html(credit_count);
      if (credit_count >= wizard.degree_plan.credits_needed) {
        $('#credit-status').removeClass('text-danger').addClass('text-success');
      } else {
        $('#credit-status').addClass('text-danger').removeClass('text-success');
      }
      
      // update required courses status
      required_complete = wizard.degree_plan.all_required_courses_complete();
      if (required_complete) {
        $('#requirement-status').removeClass('text-danger').addClass('text-success');
        $('#requirement-status').text('Complete');
      } else {
        $('#requirement-status').addClass('text-danger').removeClass('text-success');
        $('#requirement-status').text('Incomplete');
      }
      // update the course plan
      return wizard.build_course_plan();
    },
    set_degree_plan: function(new_degree_plan) {
      var group, k, len1, ref;
      wizard.degree_plan = new_degree_plan;
      wizard.clear_groups();
      ref = wizard.degree_plan.course_groups;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        group = ref[k];
        wizard.add_group(group);
      }
      $('#credits-needed').html(`${new_degree_plan.credits_needed}`);
      return wizard.setup_course_listeners();
    },
    build_course_plan: function() {
      var k, l, len1, len2, len3, len4, m, n, table_html, term_total_credits, this_year_term_courses, year_term;
      $('#course-plan').html('');
      table_html = "";
      for (k = 0, len1 = year_terms.length; k < len1; k++) {
        year_term = year_terms[k];
        this_year_term_courses = [];
        for (l = 0, len2 = courses.length; l < len2; l++) {
          course = courses[l];
          if (course.completed || course.enrolling) {
            if (course.year_term_taken.value() === year_term.value()) {
              this_year_term_courses.push(course);
            }
          }
        }
        if (this_year_term_courses.length > 0) {
          // Calculate the total credits for this term
          term_total_credits = 0;
          for (m = 0, len3 = this_year_term_courses.length; m < len3; m++) {
            course = this_year_term_courses[m];
            term_total_credits += course.credits;
          }
          table_html += "  <thead class='thead-dark'>\n";
          table_html += `    <tr><th scope='col' colspan=3 class='text-center'>${year_term}</th></tr>\n`;
          table_html += "  </thead>\n";
          table_html += "  <thead class='thead-light'>\n";
          table_html += "    <tr>\n";
          table_html += "      <th scope='col'>Course #</th>\n";
          table_html += "      <th scope='col'>Course Name</th>\n";
          table_html += "      <th scope='col'>Credits</th>\n";
          table_html += "    </tr>\n";
          table_html += "  </thead>\n";
          table_html += "  <tbody>\n";
          for (n = 0, len4 = this_year_term_courses.length; n < len4; n++) {
            course = this_year_term_courses[n];
            table_html += "    <tr>\n";
            table_html += `      <td>${course.field} ${course.number}</td>\n`;
            table_html += `      <td>${course.name}</td>\n`;
            table_html += `      <td>${course.credits}</td>\n`;
            table_html += "    </tr>\n";
          }
          
          // Add the credit summary row
          table_html += "    <tr class='bg-light font-weight-bold'>\n";
          table_html += "      <td colspan='2' class='text-right'>Term Total:</td>\n";
          table_html += `      <td>${term_total_credits}</td>\n`;
          table_html += "    </tr>\n";
          table_html += "  </tbody>\n";
        }
      }
      if (table_html !== "") {
        table_html = `<table class='table table-hover table-sm'>\n${table_html}</table>\n`;
        return $('#course-plan').html(`<h1 class='my-4'>Course Plan</h1>\n${table_html}`);
      }
    },
    setup_course_listeners: function() {
      // activate switch listeners
      $('input.completed').click(function() {
        var checkbox_id, this_course;
        // Get the ID of the checkbox
        checkbox_id = this.id;
        
        // Get the course based on the element ID
        this_course = get_course_from_element_id(checkbox_id);
        this_course.toggle_completed();
        return wizard.refresh(wizard.year_term);
      });
      $('input.enrolling').click(function() {
        var checkbox_id, this_course;
        // Get the ID of the checkbox
        checkbox_id = this.id;
        
        // Get the course based on the element ID
        this_course = get_course_from_element_id(checkbox_id);
        this_course.toggle_enrolling();
        return wizard.refresh(wizard.year_term);
      });
      // activate modal description listeners
      return $('button.description').click(function() {
        var button_id;
        // Store the original button ID to help track which course we're dealing with
        button_id = this.id;
        
        // Get the course based on the button's ID
        course = get_course_from_element_id(button_id);
        
        // Update modal content for this course
        course.update_modal(wizard.year_term);
        $('#course-info').modal();
        // Set the current course in a data attribute so we know which one to manipulate
        $('#course-info').data('current-course', course);
        $('#modal-enrolling').click(function(event) {
          event.preventDefault;
          // Get the course from the data attribute we set above
          course = $('#course-info').data('current-course');
          course.enrolling = true;
          course.completed = false;
          wizard.refresh(wizard.year_term);
          return $('#course-info').modal('hide');
        });
        return $('#modal-completed').click(function(event) {
          event.preventDefault;
          // Get the course from the data attribute we set above
          course = $('#course-info').data('current-course');
          course.enrolling = false;
          course.completed = true;
          wizard.refresh(wizard.year_term);
          return $('#course-info').modal('hide');
        });
      });
    },
    setup: function() {
      /* Year Term Menu and Next Button */
      var dp, first_year, i, k, l, len1, term, year;
      first_year = year_terms[0].year;
      first_term = year_terms[0].term.replace(/^\w/, (c) => {
        return c.toUpperCase();
      });
      // populate dropdown menu
      $('#year-term-dropdown').text(`${first_term} ${first_year}`);
      for (i = k = 0; k <= 11; i = ++k) {
        year = year_terms[i].year;
        term = year_terms[i].term.replace(/^\w/, (c) => {
          return c.toUpperCase();
        });
        $(`#year-term-menu>a[data-position='${i}']`).text(`${term} ${year}`);
      }
      // Set up listeners for year-term dropdown menu
      $('#year-term-menu>a').click(function(event) {
        var new_term, old_year_term, position;
        event.preventDefault();
        // update year-term, but hold on to old one so we can refresh, which 
        // requires knowing both the old and new term
        old_year_term = wizard.year_term;
        position = Number($(this).data('position'));
        wizard.year_term = year_terms[position];
        // move active status to new choice
        $('#year-term-menu>a').removeClass('active');
        $(`#year-term-menu>a[data-position='${position}']`).addClass('active');
        // update button text
        new_term = wizard.year_term.term.replace(/^\w/, (c) => {
          return c.toUpperCase();
        });
        $('#year-term-dropdown').text(`${new_term} ${wizard.year_term.year}`);
        wizard.refresh(old_year_term);
        // conditionally disable next button text
        if (wizard.year_term.value() === year_terms[year_terms.length - 1].value()) {
          return $('#next-term').prop('disabled', true);
        }
      });
      // get next term button working
      $('#next-term').click(function(event) {
        var new_term, old_year_term;
        event.preventDefault();
        // update year-term, but hold on to old one so we can refresh, which 
        // requires knowing both the old and new term
        old_year_term = wizard.year_term;
        wizard.year_term = wizard.year_term.next();
        new_term = wizard.year_term.term.replace(/^\w/, (c) => {
          return c.toUpperCase();
        });
        // move active status to new choice
        $('#year-term-menu>a').removeClass('active');
        $(`#year-term-menu>a:contains('${new_term} ${wizard.year_term.year}')`).addClass('active');
        
        // update button text
        new_term = wizard.year_term.term.replace(/^\w/, (c) => {
          return c.toUpperCase();
        });
        $('#year-term-dropdown').text(`${new_term} ${wizard.year_term.year}`);
        wizard.refresh(old_year_term);
        // conditionally disable next button
        if (wizard.year_term.value() === year_terms[year_terms.length - 1].value()) {
          return $('#next-term').prop('disabled', true);
        }
      });
      /* Degree Plan Dropdown */
      // initialize degree plan dropdown button text
      $('#degree-plan-dropdown').text(wizard.degree_plan.name);
// Populate degree plan dropdown
      for (l = 0, len1 = degree_plans.length; l < len1; l++) {
        dp = degree_plans[l];
        if (dp === wizard.degree_plan) {
          $('#degree-plan-menu').append(`<a class='dropdown-item degree-plan-option active' href='#'>${dp.name}</a>`);
        } else {
          $('#degree-plan-menu').append(`<a class='dropdown-item degree-plan-option' href='#'>${dp.name}</a>`);
        }
      }
      // make degree plan dropdown actually switch degree plans
      $('#degree-plan-menu>a.degree-plan-option').click(function(event) {
        var self;
        event.preventDefault();
        self = this;
        wizard.set_degree_plan(get_degree_plan(self.text));
        $('#degree-plan-menu>a.degree-plan-option').removeClass('active');
        $(`#degree-plan-menu>a.degree-plan-option:contains(${wizard.degree_plan.name})`).addClass('active');
        $('#degree-plan-dropdown').html(wizard.degree_plan.name);
        return wizard.refresh(wizard.year_term);
      });
      /* Setup Initial Degree Plan */
      wizard.set_degree_plan(wizard.degree_plan);
      // set up initial availability
      return wizard.refresh(wizard.year_term);
    }
  };

  $(document).ready(function() {
    wizard.setup();
    // enable popovers  
    $('[data-toggle="popover"]').popover();
    $('.popover-dismiss').popover({
      trigger: 'focus'
    });
    return $('a#print-page').click(function(event) {
      event.preventDefault();
      window.print();
      return setTimeout("window.close()", 100);
    });
  });

}).call(this);
